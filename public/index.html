<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>多人语音通话</title>
    <style>
      body { font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial; margin: 0; background: #0b1220; color: #e6e6e6; }
      header { padding: 16px; background: #111a2b; border-bottom: 1px solid #1f2a44; display: flex; gap: 12px; align-items: center; }
      input, button { padding: 8px 12px; border-radius: 8px; border: 1px solid #26324d; background: #0e1729; color: #e6e6e6; }
      button { cursor: pointer; }
      main { padding: 16px; display: grid; gap: 12px; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); }
      .card { border: 1px solid #1f2a44; border-radius: 12px; padding: 12px; background: #0e1729; }
      .me { border-color: #2a9d8f; }
      .peer { border-color: #264653; }
      .row { display: flex; gap: 8px; align-items: center; }
      .muted { opacity: 0.6; }
      footer { position: fixed; bottom: 0; left: 0; right: 0; padding: 12px; background: #111a2b; border-top: 1px solid #1f2a44; display: flex; justify-content: center; gap: 12px; }
    </style>
  </head>
  <body>
    <header>
      <strong>多人语音通话</strong>
      <input id="roomId" placeholder="房间ID，如: demo" />
      <button id="joinBtn">加入</button>
      <button id="leaveBtn" disabled>离开</button>
      <span id="status"></span>
    </header>
    <main>
      <div id="me" class="card me">
        <div class="row" style="justify-content: space-between">
          <div>我（本地）</div>
          <div class="row">
            <button id="muteBtn" disabled>静音</button>
          </div>
        </div>
        <audio id="localAudio" autoplay muted></audio>
      </div>
      <div id="peers"></div>
    </main>
    <footer>
      <small>提示：请使用 HTTPS 域名或 `localhost` 访问，浏览器才允许麦克风。</small>
    </footer>

    <script src="/env.js"></script>
    <script>
      const statusEl = document.getElementById('status');
      const peersEl = document.getElementById('peers');
      const roomInput = document.getElementById('roomId');
      const joinBtn = document.getElementById('joinBtn');
      const leaveBtn = document.getElementById('leaveBtn');
      const muteBtn = document.getElementById('muteBtn');
      const localAudio = document.getElementById('localAudio');

      let ws;
      let roomId = null;
      let localStream = null;
      let isMuted = false;
      const peerConnections = new Map(); // peerId -> RTCPeerConnection
      const peerAudios = new Map(); // peerId -> HTMLAudioElement

      function getWsUrl() {
        const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
        return `${protocol}://${location.host}`;
      }

      function createPeerConnection(peerId, polite) {
        const iceServers = [];
        const turnUrl = window.TURN_URL || null; // 可用 <script> 注入或服务端动态写入
        const turnUser = window.TURN_USERNAME || null;
        const turnPass = window.TURN_PASSWORD || null;
        if (turnUrl && turnUser && turnPass) {
          iceServers.push({ urls: turnUrl, username: turnUser, credential: turnPass });
        } else {
          iceServers.push({ urls: 'stun:stun.l.google.com:19302' });
        }

        const pc = new RTCPeerConnection({ iceServers });
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        pc.ontrack = (ev) => {
          const [stream] = ev.streams;
          ensurePeerCard(peerId);
          const audio = peerAudios.get(peerId);
          audio.srcObject = stream;
          audio.play().catch(() => {});
        };
        pc.onconnectionstatechange = () => {
          if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
            removePeer(peerId);
          }
        };
        pc.onicecandidate = (ev) => {
          if (ev.candidate) {
            sendSignal(peerId, { candidate: ev.candidate });
          }
        };

        peerConnections.set(peerId, pc);
        pc._polite = Boolean(polite);
        pc._makingOffer = false;
        pc._ignoreOffer = false;
        return pc;
      }

      async function makeOffer(peerId) {
        const pc = peerConnections.get(peerId);
        try {
          pc._makingOffer = true;
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          sendSignal(peerId, { description: pc.localDescription });
        } finally { pc._makingOffer = false; }
      }

      function ensurePeerCard(peerId) {
        if (peerAudios.has(peerId)) return;
        const card = document.createElement('div');
        card.className = 'card peer';
        card.id = `peer-${peerId}`;
        card.innerHTML = `<div class="row" style="justify-content: space-between"><div>对端: ${peerId}</div></div>`;
        const audio = document.createElement('audio');
        audio.autoplay = true;
        card.appendChild(audio);
        peersEl.appendChild(card);
        peerAudios.set(peerId, audio);
      }

      function removePeer(peerId) {
        const pc = peerConnections.get(peerId);
        if (pc) pc.close();
        peerConnections.delete(peerId);
        const audio = peerAudios.get(peerId);
        if (audio) {
          const card = document.getElementById(`peer-${peerId}`);
          if (card && card.parentNode) card.parentNode.removeChild(card);
        }
        peerAudios.delete(peerId);
      }

      function send(data) {
        if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(data));
      }

      function sendSignal(targetId, data) {
        send({ type: 'signal', payload: { targetId, data } });
      }

      async function handleSignal(from, data) {
        let pc = peerConnections.get(from);
        if (!pc) pc = createPeerConnection(from, /*polite*/ true);

        if (data.description) {
          const desc = data.description;
          const readyForOffer = !pc.signalingState || pc.signalingState === 'stable';
          const offerCollision = desc.type === 'offer' && (pc._makingOffer || !readyForOffer);
          pc._ignoreOffer = !pc._polite && offerCollision;
          if (pc._ignoreOffer) return;

          await pc.setRemoteDescription(desc);
          if (desc.type === 'offer') {
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            sendSignal(from, { description: pc.localDescription });
          }
        } else if (data.candidate) {
          try {
            await peerConnections.get(from)?.addIceCandidate(data.candidate);
          } catch (err) {
            if (!pc._ignoreOffer) console.error(err);
          }
        }
      }

      async function join() {
        roomId = roomInput.value.trim();
        if (!roomId) return alert('请输入房间ID');

        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          localAudio.srcObject = localStream;
        } catch (e) {
          alert('无法获取麦克风权限');
          return;
        }

        ws = new WebSocket(getWsUrl());
        ws.onopen = () => {
          send({ type: 'join', roomId });
          statusEl.textContent = `已连接，房间 ${roomId}`;
          joinBtn.disabled = true;
          leaveBtn.disabled = false;
          muteBtn.disabled = false;
        };
        ws.onmessage = async (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'peers') {
            for (const peerId of msg.peers) {
              const pc = createPeerConnection(peerId, /*polite*/ false);
              await makeOffer(peerId);
            }
          } else if (msg.type === 'peer-joined') {
            const peerId = msg.clientId;
            if (!peerConnections.has(peerId)) createPeerConnection(peerId, /*polite*/ false);
            await makeOffer(peerId);
          } else if (msg.type === 'peer-left') {
            removePeer(msg.clientId);
          } else if (msg.type === 'signal') {
            await handleSignal(msg.from, msg.data);
          }
        };
        ws.onclose = () => {
          statusEl.textContent = '连接断开';
          cleanup();
        };
      }

      function cleanup() {
        for (const peerId of [...peerConnections.keys()]) removePeer(peerId);
        if (localStream) {
          localStream.getTracks().forEach(t => t.stop());
          localStream = null;
        }
        if (ws && ws.readyState === WebSocket.OPEN) {
          send({ type: 'leave' });
        }
        if (ws) ws.close();
        joinBtn.disabled = false;
        leaveBtn.disabled = true;
        muteBtn.disabled = true;
        isMuted = false;
        muteBtn.textContent = '静音';
      }

      function toggleMute() {
        if (!localStream) return;
        isMuted = !isMuted;
        localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
        muteBtn.textContent = isMuted ? '取消静音' : '静音';
        document.getElementById('me').classList.toggle('muted', isMuted);
      }

      joinBtn.onclick = join;
      leaveBtn.onclick = cleanup;
      muteBtn.onclick = toggleMute;
    </script>
  </body>
  </html>


